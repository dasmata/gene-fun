<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js" type="text/javascript"></script>

    <script src="src/engine/Observable.js" type="text/javascript" ></script>

    <script src="src/renderers/MapRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AgentRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AgentDetailsRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/WallRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AreaRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/StatsRenderer.js" type="text/javascript" ></script>

    <script src="src/scope/SpawningBounds.js" type="text/javascript" ></script>
    <script src="src/scope/Vector.js" type="text/javascript" ></script>
    <script src="src/scope/Map.js" type="text/javascript" ></script>


    <script src="src/scope/neurons/seeLeftNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeRightNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeUpNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeDownNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/senseRandomNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveRandNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveLeftNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveRightNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveUpNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveDownNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/processingNegateNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/processingVoidNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/neuronPool.js" type="text/javascript" ></script>

    <script src="src/utils.js" type="text/javascript" ></script>

    <style>
        :root {
            --neuron-size: 40px;
        }
        h1,h2,h3,h4 {
            padding: 0;
            margin: 0;
        }
        main {
            display: flex;
            align-items: flex-start;
        }
        .map {
            width: calc(256px * (2 + 2));
            border: 1px solid black;
            z-index: 1;
            position: absolute;
        }
        .breeding-area{
            width: calc(256px * (2 + 2));
            border: 1px solid black;
            z-index: 0;
            position: absolute;
        }
        #canvas-wrapper {
            width: calc(256px * (2 + 2));
            position: relative;
        }
        #controls {
            width: 400px;
            padding-left: 5px;
        }
        .brain {
            padding: 10px 0;
        }
        .level {
            width: 500px;
            display: flex;
        }
        .level h4 {
            height: var(--neuron-size);
            padding: 5px;
            line-height: var(--neuron-size);
            width: 100px;
        }
        svg {
            display: block;
            margin-left: 110px;
        }
        .level-neurons {
            width: 390px;
            display: flex;
            justify-content: center;
            position: relative;
        }
        .level-neurons div {
            margin: 0 5px;
            border: 1px solid black;
            border-radius: 50%;
            padding: 5px;
            width: var(--neuron-size);
            height: var(--neuron-size);
            text-align: center;
            line-height: var(--neuron-size);
        }

        .level-neurons .result {
            border-radius: 0;
        }
    </style>
</head>
<body>
<main>
    <section id="canvas-wrapper"></section>
    <section id="controls">
        <span>Gen <span id="gen">0</span></span>
        <button id="killSw">Kill everyone!!</button>
        <button id="start">create</button>
        <button id="play">play</button>
        <button id="pause">pause</button>
        <div style="padding:10px">

        </div>
    </section>
</main>
<template id="agent">
    <div>
        <section id="details-container">
                <h2></h2>
                <div class="brain"></div>
                <div class="genome"></div>
                <button class="clear">clear</button>
                <button class="compute">compute</button>
            </section>
    </div>
</template>
<template id="level">
    <div class="level-row">
        <div class="level">
            <h4 class="layer-title"></h4>
            <div class="level-neurons"></div>
        </div>
        <svg width="390" height="40" id="connections"></svg>
    </div>
</template>

<template id="stats">
    <section class="stats">
        <div class="stats-row">
            <div class="stats-label">Label</div>
            <div class="stats-value">value</div>
        </div>
    </section>
</template>

<script>
    const size = {
        width: 256,
        height: 256
    };

    const levels = [
        // lvl 1
        // {
        //     walls: [],
        //     breedingAreas: [
        //         [
        //             new Vector([0, 0], Object.values(size)),
        //             new Vector([size.width / 2.5, size.height / 2.5], Object.values(size)),
        //         ],
        //         [
        //             new Vector([size.width - (size.width / 2.5), 0], Object.values(size)),
        //             new Vector([size.width, size.height / 2.5], Object.values(size)),
        //         ],
        //         [
        //             new Vector([size.width - (size.width / 2.5), size.height - (size.height / 2.5)], Object.values(size)),
        //             new Vector([size.width, size.height], Object.values(size)),
        //         ],
        //         [
        //             new Vector([0, size.height - (size.height / 2.5)], Object.values(size)),
        //             new Vector([size.width / 2.5, size.height], Object.values(size)),
        //         ],
        //     ],
        //     spawnAreas: [
        //         [
        //             new Vector([size.width / 2.5, 0], Object.values(size)),
        //             new Vector([size.width - (size.width / 2.5), size.height], Object.values(size)),
        //         ],
        //         [
        //             new Vector([0, size.height / 2.5], Object.values(size)),
        //             new Vector([size.width / 2.5, size.height - size.height / 2.5], Object.values(size)),
        //         ],
        //         [
        //             new Vector([size.width - size.width / 2.5, size.height / 2.5], Object.values(size)),
        //             new Vector([size.width, size.height - size.height / 2.5], Object.values(size)),
        //         ],
        //     ]
        // },
        // {
        //     walls: [],
        //     breedingAreas: [
        //         [
        //             new Vector([0, 0], Object.values(size)),
        //             new Vector([size.width / 6, size.height / 6], Object.values(size)),
        //         ],
        //         [
        //             new Vector([size.width - (size.width / 6), 0], Object.values(size)),
        //             new Vector([size.width, size.height / 6], Object.values(size)),
        //         ],
        //         [
        //             new Vector([size.width - (size.width / 6), size.height - (size.height / 6)], Object.values(size)),
        //             new Vector([size.width, size.height], Object.values(size)),
        //         ],
        //         [
        //             new Vector([0, size.height - (size.height / 6)], Object.values(size)),
        //             new Vector([size.width / 6, size.height], Object.values(size)),
        //         ],
        //     ],
        //     spawnAreas: [
        //         [
        //             new Vector([0, 0], Object.values(size)),
        //             new Vector([size.width, size.height], Object.values(size)),
        //         ]
        //     ]
        // },
        // lvl 2
        // {
        //     walls: [],
        //     breedingAreas: [
        //         [
        //             new Vector([size.width - (size.width / 2), 0], Object.values(size)),
        //             new Vector([size.width, (size.height / 2) - 20], Object.values(size)),
        //         ],
        //         [
        //             new Vector([size.width - (size.width / 2), (size.height / 2) + 20], Object.values(size)),
        //             new Vector([size.width, size.height], Object.values(size)),
        //         ],
        //     ],
        //     spawnAreas: [
        //         [
        //             new Vector([0, 0], Object.values(size)),
        //             new Vector([size.width, size.height], Object.values(size)),
        //         ]
        //     ]
        // },
        // lvl 3
        // {
        //     walls: [],
        //     breedingAreas: [
        //         [
        //             new Vector([size.width - (size.width / 2), 0], Object.values(size)),
        //             new Vector([size.width, (size.height / 2) - 20], Object.values(size)),
        //         ],
        //         [
        //             new Vector([size.width - (size.width / 2), (size.height / 2) + 20], Object.values(size)),
        //             new Vector([size.width, size.height], Object.values(size)),
        //         ],
        //     ],
        //     spawnAreas: [
        //         [
        //             new Vector([0, 0], Object.values(size)),
        //             new Vector([size.width / 2, size.height], Object.values(size)),
        //         ]
        //     ]
        // },
        // lvl 4
        // {
        //     walls: [],
        //     breedingAreas: [
        //         [
        //             new Vector([size.width - (size.width / 8), 0], Object.values(size)),
        //             new Vector([size.width, size.height], Object.values(size)),
        //         ],
        //     ],
        //     spawnAreas: [
        //         [
        //             new Vector([0, 0], Object.values(size)),
        //             new Vector([size.width / 2, size.height], Object.values(size)),
        //         ]
        //     ]
        // },
        // lvl 5
        // {
        //     walls: [],
        //     breedingAreas: [
        //         [new Vector([size.width - (size.width / 8), 0], Object.values(size)), new Vector([size.width, size.height], Object.values(size))],
        //     ],
        //     spawnAreas: [
        //         [
        //             new Vector([0, 0], Object.values(size)),
        //             new Vector([size.width / 8, size.height], Object.values(size)),
        //         ],
        //     ]
        // },
        // {
        //     walls: [
        //         [new Vector([180,80], Object.values(size)), new Vector([182,170], Object.values(size))],
        //     ],
        //     breedingAreas: [
        //         [new Vector([size.width - (size.width / 8), 0], Object.values(size)), new Vector([size.width, size.height], Object.values(size))],
        //     ],
        //     spawnAreas: [
        //         [
        //             new Vector([0, 0], Object.values(size)),
        //             new Vector([size.width / 8, size.height], Object.values(size)),
        //         ],
        //     ]
        // },
        {
            walls: [
                [new Vector([60,30], Object.values(size)), new Vector([62,120], Object.values(size))],
                [new Vector([60,150], Object.values(size)), new Vector([62,230], Object.values(size))],
                [new Vector([180,80], Object.values(size)), new Vector([182,170], Object.values(size))],
            ],
            breedingAreas: [
                [new Vector([size.width - (size.width / 8), 0], Object.values(size)), new Vector([size.width, size.height], Object.values(size))],
            ],
            spawnAreas: [
                [
                    new Vector([0, 30], Object.values(size)),
                    new Vector([size.width / 8, 120], Object.values(size)),
                ],
                [
                    new Vector([0, 150], Object.values(size)),
                    new Vector([size.width / 8, 230], Object.values(size)),
                ]
            ]
        },
        // lvl 6
        {
            walls: [
                [new Vector([60,30], Object.values(size)), new Vector([62,120], Object.values(size))],
                [new Vector([60,150], Object.values(size)), new Vector([62,230], Object.values(size))],
                [new Vector([180,80], Object.values(size)), new Vector([182,170], Object.values(size))],
                [new Vector([210,200], Object.values(size)), new Vector([212,256], Object.values(size))],
                [new Vector([210,0], Object.values(size)), new Vector([212,56], Object.values(size))],


                [new Vector([100,40], Object.values(size)), new Vector([160,42], Object.values(size))],
                [new Vector([100,210], Object.values(size)), new Vector([160,212], Object.values(size))],
            ],
            breedingAreas: [
                [new Vector([size.width - (size.width / 8), 0], Object.values(size)), new Vector([size.width, size.height], Object.values(size))],
            ],
            spawnAreas: [
                [
                    new Vector([0, 30], Object.values(size)),
                    new Vector([size.width / 8, 120], Object.values(size)),
                ],
                [
                    new Vector([0, 150], Object.values(size)),
                    new Vector([size.width / 8, 230], Object.values(size)),
                ]
            ]
        }
    ]

    const lastLevelNeurons = {
        mr : () => [Map.agentSize, 0],
        ml: () => [-1 * Map.agentSize, 0],
        mu: () => [0, -1 * Map.agentSize],
        md: () => [0, Map.agentSize],
        mrand: () => [
            Math.round(Math.random()) * Map.agentSize * (Math.round(Math.random()) === 0 ? -1 : 1),
            Math.round(Math.random()) * Map.agentSize * (Math.round(Math.random()) === 0 ? -1 : 1)
        ]
    };
    const STATUS_PAUSED = 0;
    const STATUS_RUNNING = 1;
    const STATUS_INITIALIZED = 2;


    class Page {
        killBtn;
        createBtn;
        pauseBtn;
        playBtn;
        controlsElement;

        actions = 1250;
        populationSize = 1000;
        geneNumber = 12;

        map;

        mapRenderer;
        detailsRenderer;
        statsRenderer;

        neuronTypes;
        population;
        initialMapData;
        status = STATUS_INITIALIZED;
        armageddonStats = {};

        constructor(){
            this.createBtn = document.getElementById('start');
            this.killBtn = document.getElementById('killSw');
            this.pauseBtn = document.getElementById('pause');
            this.playBtn = document.getElementById('play');
            this.controlsElement = document.getElementById('controls')


            this.createClickHandler = this.createClickHandler.bind(this);
            this.playClickHandler = this.playClickHandler.bind(this);
            this.pauseClickHandler = this.pauseClickHandler.bind(this);
            this.killClickHandler = this.killClickHandler.bind(this);
            this.update = this.update.bind(this);

            this.createBtn.addEventListener('click', this.createClickHandler)



            this.neuronTypes = {};
            this.population = [];



        }

        createMap() {
            this.map = new Map(
                size,
                levels
            )
            this.map.attach(this);
            this.initialMapData = this.map.toJSON();
        }

        killClickHandler(){
            this.status = STATUS_PAUSED;
            this.stopRendering();
            this.detailsRenderer = null;
            this.mapRenderer = null;
            this.statsRenderer = null;
            this.neuronTypes = {};
            this.population = [];
            this.map = null;
            this.playBtn.removeEventListener('click', this.playClickHandler);
            this.pauseBtn.removeEventListener('click', this.pauseClickHandler);
            this.createBtn.addEventListener('click', this.createClickHandler);
        }

        playClickHandler(){
            this.status = STATUS_RUNNING;
            this.updateWorker.postMessage({
                type: 'setAggregatedValues',
                payload: this.map.toJSON()
            })
            this.createBtn.removeEventListener('click', this.createClickHandler);
        }

        pauseClickHandler(){
            this.status = STATUS_PAUSED;
            this.playBtn.removeEventListener('click', this.playClickHandler);
            this.playBtn.addEventListener('click', this.playClickHandler);
        }

        createClickHandler(){
            this.createMap();
            this.status = STATUS_INITIALIZED;
            this.updateWorker = new Worker('src/engine/UpdateWorker.js', {name: 'updateWorker'});
            this.updateWorker.addEventListener('message', this.update);
            this.updateWorker.postMessage({
                type: 'init',
                payload: {
                    dependencies: [
                        '../scope/neurons/ScopeNeuron.js',
                        '../scope/neurons/VisionNeuron.js',
                    ],
                    neurons: neuronPool(this.map),
                    populationSize: this.populationSize,
                    geneNumber: this.geneNumber,
                    minActions: this.actions,
                }
            });

            this.pauseBtn.addEventListener('click', this.pauseClickHandler);
            this.killBtn.addEventListener('click', this.killClickHandler);
            this.createBtn.removeEventListener('click', this.createClickHandler);
        }

        handleWorkerReady(){
            this.map.setPopulation(this.population);
            this.statsRenderer?.render({
                ...this.armageddonStats,
                population: this.population.length
            });
            this.map.placeAgentsOnMap();
            if (this.status === STATUS_RUNNING) {
                this.playBtn.removeEventListener('click', this.playClickHandler);
                this.playClickHandler();
                this.renderAgentDetails();
                return;
            }
            if(this.status === STATUS_INITIALIZED){
                this.startRendering();
            }
            this.playBtn.addEventListener('click', this.playClickHandler);
        }

        agentClickHandler(e){
            this.detailsRenderer.render(e.payload.agent);
        }

        handleNeuronCreated(neuron) {
            this.neuronTypes[neuron.id] = {...neuron};
            this.updateWorker.postMessage({
                type: 'rpc',
                payload: {
                    ctxPath: ['neuronPool', neuron.type],
                    method: 'setMap',
                    params: [this.initialMapData]
                }
            });
        }

        handleComputed(computeResults){
            if(this.selectedAgent.id){
                this.detailsRenderer.update(computeResults[this.selectedAgent.id])
            }
            const results = Object.values(computeResults).map(entry => {
                const actionResult = this.actionAggregator(entry.results, entry.agent, this.neuronTypes);
                actionResult.reward = this.getActionReward(actionResult);
                return actionResult;
            })
            this.map.setPopulation(results);
            if(this.status === STATUS_RUNNING){
                this.updateWorker.postMessage({
                    type: 'setAggregatedValues',
                    payload: this.map.toJSON()
                })
            }
        }

        update(e){
            switch(e.data?.type || e.type){
                case 'neuronCreated':
                    this.handleNeuronCreated(e.data.payload);
                    break;
                case 'agentCreated':
                    this.population.push(e.data.payload);
                    break;
                case 'ready':
                    this.handleWorkerReady();
                    break;
                case 'computed':
                    this.handleComputed(e.data.payload);
                    break;
                case 'armageddon':
                    this.handleArmageddon()
                    break;
            }
        }

        handleArmageddon(){
            this.population = [];
            const [replicators, agentsPerArea] = this.map.findAllAgents();
            this.armageddonStats = {
                agentsPerArea,
                replicatorsNr: replicators.length
            };
            this.updateWorker.postMessage({
                type: 'createDescendants',
                payload: replicators
            })
        }

        startRendering = () => {
            this.detailsRenderer = this.detailsRenderer || new AgentDetailsRenderer(this.controlsElement, this.map, this.neuronTypes);
            this.mapRenderer = this.mapRenderer || new MapRenderer(this.map);
            this.statsRenderer = this.statsRenderer || new StatsRenderer();

            this.mapRenderer.attach(this);
            this.mapRenderer.render();
            this.statsRenderer.render(null);
            this.renderAgentDetails();
        }

        renderAgentDetails(agent){
            this.selectedAgent = agent || [...this.map.population][~~(Math.random() * this.map.population.size - 1)];
            this.detailsRenderer.render(this.selectedAgent);
        }

        stopRendering(){
            this.mapRenderer.detach(this);
            this.mapRenderer.clear();
            this.detailsRenderer.clear();
            this.statsRenderer.clear();
            this.mapRenderer = null;
            this.detailsRenderer = null;
        }

        actionAggregator(results, currentActionValue, neuronTypes) {
            const delta = [0, 0];
            Object.keys(results).forEach(id => {
                if (Object.keys(lastLevelNeurons).includes(neuronTypes[id].type)) {
                    lastLevelNeurons[neuronTypes[id].type]().forEach((el, idx) => {
                        delta[idx] += el;
                    });
                }
            })
            const currentActionVector = new Vector(currentActionValue.actionValue, Object.values(this.map.size).map(el => el - Map.agentSize));
            const deltaVectorX = new Vector([Math.abs(delta[0]), 0], Object.values(this.map.size));
            const deltaVectorY = new Vector([0, Math.abs(delta[1])], Object.values(this.map.size));
            let actionValue = currentActionVector[delta[0] < 0 ? 'subtract' : 'add'](deltaVectorX);
            actionValue = actionValue[delta[1] < 0 ? 'subtract' : 'add'](deltaVectorY);
            if(this.map.canReach(currentActionVector, actionValue)){
                currentActionValue.oldActionValue = currentActionValue.actionValue;
                currentActionValue.actionValue = actionValue.toJSON();
            }

            return currentActionValue;

        }

        getActionReward(agent) {
            if((
                agent.actionValue[0] === agent.oldActionValue[0] && agent.actionValue[0] === agent.oldActionValue[0])
            ) {
                return Math.round(Math.random());
            }
            return Math.max(...this.map.breedingAreas.map(area => {
                const middle = [...area[1].subtract(area[0])].map((el, idx) => ((el / 2) + area[0][idx]));
                const distance = [agent.actionValue[0] - middle[0], agent.actionValue[1] - middle[1]];
                const oldDistance = [agent.oldActionValue[0] - middle[0], agent.oldActionValue[1] - middle[1]];

                const diffX = distance[0] - oldDistance[0];
                const diffY = distance[1] - oldDistance[1];
                return (diffX < 0 ? -1 : (diffX > 0 ? 1 : 0)) + (diffY < 0 ? -1 : (diffY > 0 ? 1 : 0));
            }))
        }
    }

    const page = new Page();
</script>
</body>
</html>