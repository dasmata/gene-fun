<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js" type="text/javascript"></script>

    <script src="src/engine/Observable.js" type="text/javascript" ></script>

    <script src="src/renderers/MapRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AgentRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AgentDetailsRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/WallRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AreaRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/StatsRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/PageRenderer.js" type="text/javascript" ></script>

    <script src="src/scope/SpawningBounds.js" type="text/javascript" ></script>
    <script src="src/scope/Vector.js" type="text/javascript" ></script>
    <script src="src/scope/Board.js" type="text/javascript" ></script>


    <script src="src/scope/neurons/seeLeftNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeRightNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeUpNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeDownNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/senseRandomNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveActivationFunction.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/processingNegateNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/processingVoidNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/neuronPool.js" type="text/javascript" ></script>

    <script src="src/engine/utils.js" type="text/javascript" ></script>
    <script src="src/scope/config.js" type="text/javascript" ></script>
    <script src="src/FileWriter.js" type="text/javascript" ></script>
    <script src="src/EventBus.js" type="text/javascript" ></script>

    <link href="main.css" rel="stylesheet" type="text/css">
</head>
<body>
<main>
    <section id="canvas-wrapper"></section>
    <section id="controls">
        <fieldset>
            <legend>Training</legend>
            <label class="switch">
                <input type="checkbox">
                <span class="slider round"></span>
            </label>
        </fieldset>
        <fieldset>
            <legend>Controls</legend>
            <span>Gen <span id="gen">0</span></span>
            <button id="killSw">Kill everyone!!</button>
            <button id="start">create</button>
            <button id="play">play</button>
            <button id="pause">pause</button>
            <label>
                <span>Level: </span>
                <input name="level" type="number" id="level-indicator" min="0" />
            </label>
            <label>
                <span>Actions: </span>
                <input name="actions" type="range" min="1" max="10000" id="actions-slider" oninput="this.nextElementSibling.value = this.value" />
                <output></output>
            </label>
            <label>
                <span>Gene nr: </span>
                <input name="geneNumber" type="range" id="genes-slider" max="20" min="1" oninput="this.nextElementSibling.value = this.value" />
                <output></output>
            </label>
            <label>
                <span>Min survivability: </span>
                <input name="survivabilityThreshold" type="range" id="survivability-slider" oninput="this.nextElementSibling.value = this.value" />
                <output></output>
            </label>
        </fieldset>

        <fieldset id="import-export">
            <legend>Import / Export agents</legend>
            <button id="save-current">Save current population</button>
            <button id="save-best">Save best population</button>
            <label>
                <span>Import agents<br /><sub>(json format)<sub></span>
                <input type="file" id="import-population" />
            </label>
        </fieldset>
    </section>
</main>
<template id="agent">
    <div>
        <fieldset id="details-container">
            <legend>Agent details</legend>
            <h2></h2>
            <div class="brain"></div>
            <div class="genome"></div>
            <button class="clear">clear</button>
            <button class="compute">compute</button>
        </fieldset>
    </div>
</template>
<template id="level">
    <div class="level-row">
        <div class="level">
            <h4 class="layer-title"></h4>
            <div class="level-neurons"></div>
        </div>
        <svg width="390" height="40" id="connections"></svg>
    </div>
</template>

<template id="stats">
    <fieldset class="stats">
        <legend>Stats</legend>
        <div class="stats-row">
            <div class="stats-label">Label</div>
            <div class="stats-value">value</div>
        </div>
    </fieldset>
</template>

<script>
    let startMark = null
    let endMark = null;
    const lastLevelNeurons = {
        mr : () => [Board.agentSize, 0],
        ml: () => [-1 * Board.agentSize, 0],
        mu: () => [0, -1 * Board.agentSize],
        md: () => [0, Board.agentSize],
        mrand: () => [
            Math.round(Math.random()) * Board.agentSize * (Math.round(Math.random()) === 0 ? 1 : -1),
            Math.round(Math.random()) * Board.agentSize * (Math.round(Math.random()) === 0 ? 1 : -1)
        ],
        mrand2: () => [
            Math.round(Math.random()) * Board.agentSize * (Math.round(Math.random()) === 0 ? 1 : -1),
            Math.round(Math.random()) * Board.agentSize * (Math.round(Math.random()) === 0 ? 1 : -1)
        ]
    };
    const STATUS_PAUSED = 0;
    const STATUS_RUNNING = 1;
    const STATUS_INITIALIZED = 2;

    const methodEventsMap = {
        neuronCreated: 'handleNeuronCreated',
        agentCreated: 'agentCreated',
        ready: 'handleWorkerReady',
        computed: 'handleComputed',
        armageddon: 'handleArmageddon',
        agentClick: 'agentClickHandler',
        computeRequest: 'computeRequest',
        rpcResponse: 'rpcResponse',
        create: 'createHandler',
        play: 'playHandler',
        kill: 'killHandler',
        pause: 'pauseHandler',
        save: 'saveHandler',
        importAgents: 'importAgents'
    }


    class Page {
        actions = 2000;
        populationSize = 1000;
        geneNumber = 18;
        survivabilityThreshold = 60;
        level = 0;

        map;

        mapRenderer;
        detailsRenderer;
        statsRenderer;
        pageRenderer;

        neuronTypes;
        population;
        initialMapData;
        status = STATUS_INITIALIZED;
        armageddonStats = {};
        rpcCallbacks = new Map();

        bestPopulation = [];

        constructor(config){
            this.config = config;
            Object.keys(methodEventsMap).forEach(messageType => {
                EventBus.subscribe(messageType, this[methodEventsMap[messageType]].bind(this));
            });
            this.update = this.update.bind(this);
            this.neuronTypes = {};
            this.population = [];
            this.pageRenderer = new PageRenderer(this);
            EventBus.subscribe('paramChange', e => {
                if(typeof this[e.name] !== 'undefined'){
                    this[e.name] = e.value;
                }
                if(e.name === 'geneNumber' || e.name === 'actions'){
                    this.sendRpc(
                        [],
                        `set${e.name.slice(0,1).toUpperCase()}${e.name.slice(1)}`,
                        [e.value]
                    )
                }
            });
        }

        createMap() {
            this.map = new Board(
                this.config.size,
                this.config.levels,
                this.level
            )
            this.map.population = [];
            this.population = [];
            this.initialMapData = this.map.toJSON();
        }

        killHandler(){
            this.status = STATUS_PAUSED;
            this.stopRendering();
            this.neuronTypes = {};
            this.population = [];
            this.map = null;
        }

        playHandler(){
            startMark = performance.mark('aaa');
            this.status = STATUS_RUNNING;
            this.updateWorker.postMessage({
                type: 'setAggregatedValues',
                payload: this.map.toJSON()
            });
        }

        pauseHandler(){
            this.status = STATUS_PAUSED;
        }

        createHandler(){
            this.createMap();
            this.status = STATUS_INITIALIZED;
            this.updateWorker = new Worker('src/engine/WorkerMaster.js', {name: 'updateWorker'});
            this.updateWorker.addEventListener('message', this.update);
            this.updateWorker.postMessage({
                type: 'init',
                payload: {
                    dependencies: [
                        '../scope/neurons/ScopeNeuron.js',
                        '../scope/neurons/VisionNeuron.js',
                    ],
                    neurons: neuronPool(this.map),
                    populationSize: this.populationSize,
                    geneNumber: this.geneNumber,
                    minActions: this.actions,
                    config: this.config.engineConfig
                }
            });
        }

        saveHandler(type){
            const population = type === 'best' ?  this.bestPopulation : this.map?.population;
            const filename = type === 'best' ?  'bestPopulation' : 'currentPopulation';
            if(!population?.length){
                console.error('Not enough data');
                return;
            }
            const writer = new FileWriter()
            writer.download(JSON.stringify(population), `${filename}.json`);
        }

        handleWorkerReady(){
            this.map.setPopulation(this.population);
            this.statsRenderer?.render({
                armageddonStats: this.armageddonStats,
                population: this.population.length
            });
            this.map.placeAgentsOnMap();
            if (this.status === STATUS_RUNNING) {
                this.playHandler();
                this.renderAgentDetails();
                return;
            }
            if(this.status === STATUS_INITIALIZED){
                this.startRendering();
                this.sendRpc([], 'setAgentsActionValues', [this.map.toJSON().agents], () => {
                    console.log('Agents set on map');
                })
            }
        }

        agentClickHandler({ agent }){
            this.renderAgentDetails(agent);
        }

        sendNeuronContext(type, msgId){
            this.sendRpc(['neuronPool', type], 'setContext', [this.initialMapData], null, msgId);
        }

        sendRpc(path, method, params, callback, threadIdentifier) {
            const id = `${Math.random().toString(36).substring(2,7)}-${Math.random().toString(36).substring(2,7)}-${Math.random().toString(36).substring(2,7)}`;
            try {
                this.updateWorker?.postMessage({
                    type: 'rpc',
                    payload: {
                        ctxPath: path,
                        method: method,
                        params: params,
                        rpcId: id
                    },
                    reqId: threadIdentifier
                })
                this.rpcCallbacks.set(id, callback || (() => {}));
            } catch (e) {
                console.error(e);
            }
            return id;
        }

        handleNeuronCreated(e) {
            const neuron = e.data.payload;
            this.neuronTypes[neuron.id] = {...neuron};
            this.sendNeuronContext(neuron.type, e.data.msgId);
        }

        handleComputed(e){
            const computeResults = e.data.payload;
            if(this.selectedAgent.id){
                this.detailsRenderer.update(computeResults[this.selectedAgent.id])
            }
            const results = Object.values(computeResults).map(entry => {
                const actionResult = this.actionAggregator(entry.results, entry.agent, this.neuronTypes);
                actionResult.reward = this.getActionReward(actionResult);
                return actionResult;
            });
            this.map.setPopulation(results);
            if(this.status === STATUS_RUNNING){
                this.updateWorker.postMessage({
                    type: 'setAggregatedValues',
                    payload: this.map.toJSON()
                })
            }
        }

        handleArmageddon(){
            this.population = [];
            const [replicators, agentsPerArea] = this.map.findAllAgents();
            const survivability = Math.round((replicators.length / this.map.population.length) * 10000) / 100;
            if(survivability > this.armageddonStats.survivability){
                this.bestPopulation = this.map.population;
            }
            this.armageddonStats = {
                agentsPerArea,
                replicatorsNr: replicators.length,
                populationSize: this.map.population.length,
                survivability,
                maxSurvivability: Math.max(this.armageddonStats?.maxSurvivability || 0, survivability)
            };
            if (survivability > this.survivabilityThreshold){
                alert('Great success!!');
                return;
            }
            this.levelUp();
            this.map.population = [];

            endMark = performance.mark('aaa');
            console.log(endMark.startTime - startMark.startTime);
            this.updateWorker.postMessage({
                type: 'createDescendants',
                payload: JSON.parse(JSON.stringify(replicators))
            })
        }

        levelUp(){
            this.map.nextLevel();
            this.initialMapData = this.map.toJSON();
            Object.keys(this.neuronTypes).forEach(id => {
                this.sendNeuronContext(this.neuronTypes[id].type);
            });
            this.mapRenderer.clear();
            this.mapRenderer.render();
        }

        startRendering = () => {
            this.detailsRenderer = this.detailsRenderer || new AgentDetailsRenderer(document.getElementById('controls'), this.map, this.neuronTypes);
            this.mapRenderer = this.mapRenderer || new MapRenderer(this.map);
            this.statsRenderer = this.statsRenderer || new StatsRenderer(document.getElementById('controls'));

            this.mapRenderer.render();
            this.statsRenderer.render({
                population: this.map.population.length
            });
            this.renderAgentDetails();
        }

        renderAgentDetails(agent){
            this.selectedAgent = agent || [...this.map.population][~~(Math.random() * this.map.population.length - 1)];
            this.detailsRenderer.render(this.selectedAgent);
            EventBus.publish('selectedAgent', this.selectedAgent);
        }

        stopRendering(){
            EventBus.publish('stopRender');
            this.mapRenderer = null;
            this.detailsRenderer = null;
            this.statsRenderer = null;
        }

        actionAggregator(results, currentActionValue, neuronTypes) {
            const delta = [0, 0];
            Object.keys(results).forEach(id => {
                if (Object.keys(lastLevelNeurons).includes(neuronTypes[id].type)) {
                    if(results[id].val === 1){
                        lastLevelNeurons[neuronTypes[id].type]().forEach((el, idx) => {
                            delta[idx] += el;
                        });
                    }
                }
            })
            const currentActionVector = new Vector(currentActionValue.actionValue, Object.values(this.map.size).map(el => el - Board.agentSize));
            const deltaVectorX = new Vector([Math.abs(delta[0]), 0], Object.values(this.map.size));
            const deltaVectorY = new Vector([0, Math.abs(delta[1])], Object.values(this.map.size));
            let actionValue = currentActionVector[delta[0] < 0 ? 'subtract' : 'add'](deltaVectorX);
            actionValue = actionValue[delta[1] < 0 ? 'subtract' : 'add'](deltaVectorY);
            if(this.map.canReach(currentActionVector, actionValue)){
                currentActionValue.oldActionValue = currentActionValue.actionValue;
                currentActionValue.actionValue = actionValue.toJSON();
            }
            return currentActionValue;

        }

        getActionReward(agent) {
            if((
                agent.actionValue[0] === agent.oldActionValue[0] && agent.actionValue[0] === agent.oldActionValue[0])
            ) {
                return Math.round(Math.random() * 5) * (Math.round(Math.random()) === 0 ? 1 : -1);
            }
            return Math.max(...this.map.breedingAreas.map(area => {
                const middle = [...area[1].subtract(area[0])].map((el, idx) => ((el / 2) + area[0][idx]));
                const distance = [
                    Math.abs(agent.actionValue[0] - middle[0]),
                    Math.abs(agent.actionValue[1] - middle[1])
                ];
                const oldDistance = [
                    Math.abs(agent.oldActionValue[0] - middle[0]),
                    Math.abs(agent.oldActionValue[1] - middle[1])
                ];

                return (
                    distance[0] > oldDistance[0]
                        ? -1
                        : (distance[0] < oldDistance[0]
                            ? 1
                            : 0
                        )
                ) + (
                    distance[1] > oldDistance[1]
                        ? -1
                        : (distance[1] < oldDistance[1]
                            ? 1
                            : 0
                        )
                );
            }))
        }

        computeRequest(agent) {
            this.sendRpc([], 'testRunNeurons', [agent.id], response => {
                const actionResult = this.actionAggregator(
                    response,
                    {
                        ...agent,
                        actionValue: [...agent.actionValue],
                        oldActionValue: [...agent.oldActionValue]
                    },
                    this.neuronTypes
                );
                actionResult.reward = this.getActionReward(actionResult);
                this.map.population.forEach(agent => {
                    if (agent.id === actionResult.id) {
                        agent.actionValue = actionResult.actionValue;
                        agent.oldActionValue = actionResult.oldActionValue;
                    }
                });

                this.detailsRenderer.update({
                    results: response,
                    agent: actionResult
                })
            });
        }

        agentCreated(e){
            this.population.push(e.data.payload);
        }

        rpcResponse(e) {
            if (this.rpcCallbacks.has(e.data.payload.rpcId)) {
                this.rpcCallbacks.get(e.data.payload.rpcId)(e.data.payload.response);
            }
        }

        importAgents(agents){
            if(!this.map){
                this.createHandler();
            }
            const readyCallback = () => {
                this.stopRendering();
                unsubscribe();
                this.map.population = [];
                this.population = [];
                this.updateWorker.postMessage({
                    type: 'importAgents',
                    payload: agents
                });
                this.pageRenderer.setReadyState();
            };
            const unsubscribe = EventBus.subscribe('ready', readyCallback);
        }

        update(e){
            EventBus.publish(e.data?.type || e.type, e);
        }

    }

    var page = new Page(config);
</script>
</body>
</html>