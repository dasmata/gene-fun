<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js" type="text/javascript"></script>

    <script src="src/engine/Observable.js" type="text/javascript" ></script>

    <script src="src/renderers/MapRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AgentRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AgentDetailsRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/WallRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/AreaRenderer.js" type="text/javascript" ></script>
    <script src="src/renderers/StatsRenderer.js" type="text/javascript" ></script>

    <script src="src/scope/SpawningBounds.js" type="text/javascript" ></script>
    <script src="src/scope/Vector.js" type="text/javascript" ></script>
    <script src="src/scope/Board.js" type="text/javascript" ></script>


    <script src="src/scope/neurons/seeLeftNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeRightNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeUpNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/seeDownNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/senseRandomNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveRandNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveLeftNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveRightNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveUpNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/moveDownNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/processingNegateNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/processingVoidNeuron.js" type="text/javascript" ></script>
    <script src="src/scope/neurons/neuronPool.js" type="text/javascript" ></script>

    <script src="src/utils.js" type="text/javascript" ></script>
    <script src="src/scope/config.js" type="text/javascript" ></script>

    <style>
        :root {
            --neuron-size: 40px;
        }
        h1,h2,h3,h4 {
            padding: 0;
            margin: 0;
        }
        main {
            display: flex;
            align-items: flex-start;
        }
        .map {
            width: calc(256px * (2 + 2));
            border: 1px solid black;
            z-index: 1;
            position: absolute;
        }
        .breeding-area{
            width: calc(256px * (2 + 2));
            border: 1px solid black;
            z-index: 0;
            position: absolute;
        }
        #canvas-wrapper {
            width: calc(256px * (2 + 2));
            position: relative;
        }
        #controls {
            width: 400px;
            padding-left: 5px;
        }
        .brain {
            padding: 10px 0;
        }
        .level {
            width: 500px;
            display: flex;
        }
        .level h4 {
            height: var(--neuron-size);
            padding: 5px;
            line-height: var(--neuron-size);
            width: 100px;
        }
        svg {
            display: block;
            margin-left: 110px;
        }
        .level-neurons {
            width: 390px;
            display: flex;
            justify-content: center;
            position: relative;
        }
        .level-neurons div {
            margin: 0 5px;
            border: 1px solid black;
            border-radius: 50%;
            padding: 5px;
            width: var(--neuron-size);
            height: var(--neuron-size);
            text-align: center;
            line-height: var(--neuron-size);
        }

        .level-neurons .result {
            border-radius: 0;
        }
    </style>
</head>
<body>
<main>
    <section id="canvas-wrapper"></section>
    <section id="controls">
        <span>Gen <span id="gen">0</span></span>
        <button id="killSw">Kill everyone!!</button>
        <button id="start">create</button>
        <button id="play">play</button>
        <button id="pause">pause</button>
        <div style="padding:10px">

        </div>
    </section>
</main>
<template id="agent">
    <div>
        <section id="details-container">
                <h2></h2>
                <div class="brain"></div>
                <div class="genome"></div>
                <button class="clear">clear</button>
                <button class="compute">compute</button>
            </section>
    </div>
</template>
<template id="level">
    <div class="level-row">
        <div class="level">
            <h4 class="layer-title"></h4>
            <div class="level-neurons"></div>
        </div>
        <svg width="390" height="40" id="connections"></svg>
    </div>
</template>

<template id="stats">
    <section class="stats">
        <div class="stats-row">
            <div class="stats-label">Label</div>
            <div class="stats-value">value</div>
        </div>
    </section>
</template>

<script>
    const lastLevelNeurons = {
        mr : () => [Board.agentSize, 0],
        ml: () => [-1 * Board.agentSize, 0],
        mu: () => [0, -1 * Board.agentSize],
        md: () => [0, Board.agentSize],
        mrand: () => [
            Math.round(Math.random()) * Board.agentSize * (Math.round(Math.random()) === 0 ? 1 : -1),
            Math.round(Math.random()) * Board.agentSize * (Math.round(Math.random()) === 0 ? 1 : -1)
        ]
    };
    const STATUS_PAUSED = 0;
    const STATUS_RUNNING = 1;
    const STATUS_INITIALIZED = 2;


    class Page {
        killBtn;
        createBtn;
        pauseBtn;
        playBtn;
        controlsElement;

        actions = 1250;
        populationSize = 1000;
        geneNumber = 12;
        survivabilityThreshold = 60;

        map;

        mapRenderer;
        detailsRenderer;
        statsRenderer;

        neuronTypes;
        population;
        initialMapData;
        status = STATUS_INITIALIZED;
        armageddonStats = {};
        rpcCallbacks = new Map();

        constructor(config){
            this.createBtn = document.getElementById('start');
            this.killBtn = document.getElementById('killSw');
            this.pauseBtn = document.getElementById('pause');
            this.playBtn = document.getElementById('play');
            this.controlsElement = document.getElementById('controls')
            this.config = config;


            this.createClickHandler = this.createClickHandler.bind(this);
            this.playClickHandler = this.playClickHandler.bind(this);
            this.pauseClickHandler = this.pauseClickHandler.bind(this);
            this.killClickHandler = this.killClickHandler.bind(this);
            this.update = this.update.bind(this);

            this.createBtn.addEventListener('click', this.createClickHandler)



            this.neuronTypes = {};
            this.population = [];



        }

        createMap() {
            this.map = new Board(
                this.config.size,
                this.config.levels
            )
            this.map.attach(this);
            this.initialMapData = this.map.toJSON();
        }

        killClickHandler(){
            this.status = STATUS_PAUSED;
            this.stopRendering();
            this.detailsRenderer = null;
            this.mapRenderer = null;
            this.statsRenderer = null;
            this.neuronTypes = {};
            this.population = [];
            this.map = null;
            this.playBtn.removeEventListener('click', this.playClickHandler);
            this.pauseBtn.removeEventListener('click', this.pauseClickHandler);
            this.createBtn.addEventListener('click', this.createClickHandler);
        }

        playClickHandler(){
            this.status = STATUS_RUNNING;
            this.updateWorker.postMessage({
                type: 'setAggregatedValues',
                payload: this.map.toJSON()
            })
            this.createBtn.removeEventListener('click', this.createClickHandler);
        }

        pauseClickHandler(){
            this.status = STATUS_PAUSED;
            this.playBtn.removeEventListener('click', this.playClickHandler);
            this.playBtn.addEventListener('click', this.playClickHandler);
        }

        createClickHandler(){
            this.createMap();
            this.status = STATUS_INITIALIZED;
            this.updateWorker = new Worker('src/engine/UpdateWorker.js', {name: 'updateWorker'});
            this.updateWorker.addEventListener('message', this.update);
            this.updateWorker.postMessage({
                type: 'init',
                payload: {
                    dependencies: [
                        '../scope/neurons/ScopeNeuron.js',
                        '../scope/neurons/VisionNeuron.js',
                    ],
                    neurons: neuronPool(this.map),
                    populationSize: this.populationSize,
                    geneNumber: this.geneNumber,
                    minActions: this.actions,
                }
            });

            this.pauseBtn.addEventListener('click', this.pauseClickHandler);
            this.killBtn.addEventListener('click', this.killClickHandler);
            this.createBtn.removeEventListener('click', this.createClickHandler);
        }

        handleWorkerReady(){
            this.map.setPopulation(this.population);
            this.statsRenderer?.render({
                armageddonStats: this.armageddonStats,
                population: this.population.length
            });
            this.map.placeAgentsOnMap();
            if (this.status === STATUS_RUNNING) {
                this.playBtn.removeEventListener('click', this.playClickHandler);
                this.playClickHandler();
                this.renderAgentDetails();
                return;
            }
            if(this.status === STATUS_INITIALIZED){
                this.startRendering();
            }
            this.playBtn.addEventListener('click', this.playClickHandler);
        }

        agentClickHandler(payload){
            this.renderAgentDetails(payload.agent);
        }

        sendNeuronContext(type){
            this.sendRpc(['neuronPool', type], 'setContext', [this.initialMapData]);
        }

        sendRpc(path, method, params, callback) {
            const id = `${Math.random().toString(36).substring(2,7)}-${Math.random().toString(36).substring(2,7)}-${Math.random().toString(36).substring(2,7)}`;
            this.updateWorker.postMessage({
                type: 'rpc',
                payload: {
                    ctxPath: path,
                    method: method,
                    params: params,
                    reqId: id
                }
            });
            this.rpcCallbacks.set(id, callback || (() => {}));
            return id;
        }

        handleNeuronCreated(neuron) {
            this.neuronTypes[neuron.id] = {...neuron};
            this.sendNeuronContext(neuron.type);
        }

        handleComputed(computeResults){
            if(this.selectedAgent.id){
                this.detailsRenderer.update(computeResults[this.selectedAgent.id])
            }
            const results = Object.values(computeResults).map(entry => {
                const actionResult = this.actionAggregator(entry.results, entry.agent, this.neuronTypes);
                actionResult.reward = this.getActionReward(actionResult);
                return actionResult;
            })
            this.map.setPopulation(results);
            if(this.status === STATUS_RUNNING){
                this.updateWorker.postMessage({
                    type: 'setAggregatedValues',
                    payload: this.map.toJSON()
                })
            }
        }

        handleArmageddon(){
            this.population = [];
            const [replicators, agentsPerArea] = this.map.findAllAgents();
            const survivability = Math.round((replicators.length / this.map.population.length) * 10000) / 100;
            this.armageddonStats = {
                agentsPerArea,
                replicatorsNr: replicators.length,
                populationSize: this.map.population.length,
                survivability,
                maxSurvivability: Math.max(this.armageddonStats?.maxSurvivability || 0, survivability)
            };
            if (survivability > this.survivabilityThreshold){
                try{
                    this.levelUp();
                } catch (e) {
                    alert('Great success!!');
                    return;
                }
            }
            this.updateWorker.postMessage({
                type: 'createDescendants',
                payload: replicators
            })
        }

        levelUp(){
            this.map.nextLevel();
            this.initialMapData = this.map.toJSON();
            Object.keys(this.neuronTypes).forEach(id => {
                this.sendNeuronContext(this.neuronTypes[id].type);
            });
        }

        startRendering = () => {
            this.detailsRenderer = this.detailsRenderer || new AgentDetailsRenderer(this.controlsElement, this.map, this.neuronTypes);
            this.mapRenderer = this.mapRenderer || new MapRenderer(this.map);
            this.statsRenderer = this.statsRenderer || new StatsRenderer(this.controlsElement);

            this.mapRenderer.attach(this);
            this.detailsRenderer.attach(this);

            this.mapRenderer.render();
            this.statsRenderer.render({
                population: this.map.population.length
            });
            this.renderAgentDetails();
        }

        renderAgentDetails(agent){
            this.selectedAgent = agent || [...this.map.population][~~(Math.random() * this.map.population.length - 1)];
            this.detailsRenderer.render(this.selectedAgent);
        }

        stopRendering(){
            this.mapRenderer.detach(this);
            this.mapRenderer.clear();
            this.detailsRenderer.clear();
            this.statsRenderer.clear();
            this.mapRenderer = null;
            this.detailsRenderer = null;
        }

        actionAggregator(results, currentActionValue, neuronTypes) {
            const delta = [0, 0];
            Object.keys(results).forEach(id => {
                if (Object.keys(lastLevelNeurons).includes(neuronTypes[id].type)) {
                    if(results[id].val === 1){
                        lastLevelNeurons[neuronTypes[id].type]().forEach((el, idx) => {
                            delta[idx] += el;
                        });
                    }
                }
            })
            const currentActionVector = new Vector(currentActionValue.actionValue, Object.values(this.map.size).map(el => el - Board.agentSize));
            const deltaVectorX = new Vector([Math.abs(delta[0]), 0], Object.values(this.map.size));
            const deltaVectorY = new Vector([0, Math.abs(delta[1])], Object.values(this.map.size));
            let actionValue = currentActionVector[delta[0] < 0 ? 'subtract' : 'add'](deltaVectorX);
            actionValue = actionValue[delta[1] < 0 ? 'subtract' : 'add'](deltaVectorY);
            if(this.map.canReach(currentActionVector, actionValue)){
                currentActionValue.oldActionValue = currentActionValue.actionValue;
                currentActionValue.actionValue = actionValue.toJSON();
            }

            return currentActionValue;

        }

        getActionReward(agent) {
            if((
                agent.actionValue[0] === agent.oldActionValue[0] && agent.actionValue[0] === agent.oldActionValue[0])
            ) {
                return Math.round(Math.random());
            }
            return Math.max(...this.map.breedingAreas.map(area => {
                const middle = [...area[1].subtract(area[0])].map((el, idx) => ((el / 2) + area[0][idx]));
                const distance = [agent.actionValue[0] - middle[0], agent.actionValue[1] - middle[1]];
                const oldDistance = [agent.oldActionValue[0] - middle[0], agent.oldActionValue[1] - middle[1]];

                const diffX = distance[0] - oldDistance[0];
                const diffY = distance[1] - oldDistance[1];
                return (diffX < 0 ? -1 : (diffX > 0 ? 1 : 0)) + (diffY < 0 ? -1 : (diffY > 0 ? 1 : 0));
            }))
        }

        update(e){
            switch(e.data?.type || e.type){
                case 'neuronCreated':
                    this.handleNeuronCreated(e.data.payload);
                    break;
                case 'agentCreated':
                    this.population.push(e.data.payload);
                    break;
                case 'ready':
                    this.handleWorkerReady();
                    break;
                case 'computed':
                    this.handleComputed(e.data.payload);
                    break;
                case 'armageddon':
                    this.handleArmageddon()
                    break;
                case 'agentClick':
                    this.agentClickHandler(e.payload)
                    break;
                case 'computeRequest':
                    this.sendRpc([], 'testRunNeurons', [e.payload.id], response => {
                        const actionResult = this.actionAggregator(
                            response,
                            {
                                ...e.payload,
                                actionValue: [...e.payload.actionValue],
                                oldActionValue: [...e.payload.oldActionValue]
                            },
                            this.neuronTypes
                        );
                        console.log(actionResult)
                        actionResult.reward = this.getActionReward(actionResult);
                        this.map.population.forEach(agent => {
                            if (agent.id === actionResult.id) {
                                agent.actionValue = actionResult.actionValue;
                                agent.oldActionValue = actionResult.oldActionValue;
                            }
                        });

                        this.detailsRenderer.update({
                            results: response,
                            agent: actionResult
                        })
                        console.log(response);
                    });
                    break;
                case 'rpcResponse':
                    if (this.rpcCallbacks.has(e.data.payload.reqId)) {
                        this.rpcCallbacks.get(e.data.payload.reqId)(e.data.payload.response);
                    }
                    break;
            }
        }

    }

    const page = new Page(config);
</script>
</body>
</html>